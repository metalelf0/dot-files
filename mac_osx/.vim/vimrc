set t_Co=256
set nocompatible
set number
set ruler
syntax on
set encoding=utf-8
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
" set list listchars=tab:\ \ ,trail:Â·
set hlsearch
set incsearch
set ignorecase
set smartcase
set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.rbc,*.class,.svn,vendor/gems/*
set laststatus=2
" set cul
set autoindent

set wrap
set linebreak
set nolist  " list disables linebreak

let g:molokai_original=0

" make rvm happy
set shell=/bin/sh

" rvm ruby configuration
" let g:ruby_path="/Users/metalelf0/.rvm/bin/ruby"

" Show (partial) command in the status line
set showcmd

" Remember last location in file
if has("autocmd")
  au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
    \| exe "normal g'\"" | endif
endif

" Include user's local vim config
if filereadable(expand("~/Dropbox/vim.local/macros.rc"))
  source ~/Dropbox/vim.local/macros.rc
endif

" Include user's local vim config
if filereadable(expand("~/Dropbox/vim.local/vimrc"))
  source ~/Dropbox/vim.local/vimrc
endif

function! NeatFoldText() "{{{2
  let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
  let lines_count = v:foldend - v:foldstart + 1
  let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')
  let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
set foldtext=NeatFoldText()
" }}}2

function! s:TextEnableCodeSnip(filetype,start,end,textSnipHl) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  if exists('b:current_syntax')
    let s:current_syntax=b:current_syntax
    " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
    " do nothing if b:current_syntax is defined.
    unlet b:current_syntax
  endif
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  try
    execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
  catch
  endtry
  if exists('s:current_syntax')
    let b:current_syntax=s:current_syntax
  else
    unlet b:current_syntax
  endif
  execute 'syntax region textSnip'.ft.'
  \ matchgroup='.a:textSnipHl.'
  \ start="'.a:start.'" end="'.a:end.'"
  \ contains=@'.group
endfunction


" load the plugin and indent settings for the detected filetype
filetype plugin indent on

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

" make uses real tabs
au FileType make set noexpandtab

" Thorfile, Rakefile, Vagrantfile and Gemfile are Ruby
au BufRead,BufNewFile {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru}    set ft=ruby

" add json syntax highlighting
au BufNewFile,BufRead *.json set ft=javascript

au BufEnter,BufNewFile,BufRead journal.md call s:TextEnableCodeSnip('vimt0d0', '#{{{t0d0', '#t0d0}}}', 'SpecialComment')

" double tap esc to clear highlighting after search
nnoremap <silent> <Esc><Esc> :nohlsearch<CR>

" :w!! saves a file as root
cmap w!! w !sudo tee % >/dev/null

function! DeleteRubyComments()
  g/#.*$/d
endfunction

nmap <silent> <Leader>dc call DeleteRubyComments()


" Use modeline overrides
set modeline
set modelines=10

" no backup please

set nobackup

" " Directories for swp files
set backupdir=~/.vim_backup
set directory=~/.vim_backup

" MacVIM shift+arrow-keys behavior (required in .vimrc)
let macvim_hig_shift_movement = 1

" nmap <Tab><Tab> :vsplit .<CR>

" NERDCommenter configuration
" add extra spaces around delimiters
let NERDSpaceDelims=1

" gist-vim defaults
if has("mac")
  let g:gist_clip_command = 'pbcopy'
elseif has("unix")
  let g:gist_clip_command = 'xclip -selection clipboard'
endif
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

"" Github flavoured markdown
augroup markdown
    au!
    au BufNewFile,BufRead *.md,*.markdown setlocal filetype=ghmarkdown
augroup END

" CTags
noremap <Leader>rt :!ctags --extra=+f -R *<CR><CR>
noremap <C-\> :tnext<CR>

" pomodoro.vim
let g:pomodoro_time_work = 25
let g:pomodoro_time_slack = 5
let g:pomodoro_do_log = 1
let g:pomodoro_log_file = "/Users/metalelf0/Documents/pomodoro_log.txt"

" http://stackoverflow.com/questions/5375240/a-more-useful-statusline-in-vim
" http://got-ravings.blogspot.it/2008/08/vim-pr0n-making-statuslines-that-own.html

    " set statusline=
    " set statusline +=%#Identifier#\ %n\ %*                  " buffer number
    " set statusline +=%#PreProc#%{&ff}%*                     " file format
    " set statusline +=%#Number#%y%*                          " file type
    " set statusline +=%#String#\ %<%t%*                      " full path
    " set statusline +=%#SpecialKey#%m%*                      " modified flag
    " set statusline +=%#Identifier#\ %{PomodoroStatus()}\ %* " pomodoro status
    " set statusline +=%=%*                                   " padding
    " set statusline +=%#Identifier#%5l%*                     " current line
    " set statusline +=%#SpecialKey#/%L%*                     " total lines
    " set statusline +=%#Identifier#%4v\ %*                   " virtual column number
    " set statusline +=%#SpecialKey#0x%04B\ %*                " character under cursor

" -k means 'only filetypes known to ACK'
"  if something is missing, look into ack --help-types
" let g:ackprg='/usr/local/bin/ack -H --nocolor --nogroup --column'
" let g:agprg='/Users/metalelf0/bin/agg --column'

let @l='Hilet(:WbEa)f=r{A }jH'
let @n='Gy17kggP<Esc>:read !gdate "+\%B \%d, \%A"kdd'

let s:extrarc = expand($HOME . '.vim/ctrlp_rc.vim')
if filereadable(s:extrarc)
    exec ':so ' . s:extrarc
endif

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

 " let Vundle manage Vundle " required!
  Plugin 'gmarik/vundle'
  Plugin 'Valloric/YouCompleteMe'
  Plugin 'metalelf0/vimt0d0.git'
  " Plugin 'mileszs/ack.vim.git'
  Plugin 'scrooloose/nerdcommenter.git'
  " Plugin 'scrooloose/syntastic.git'
  Plugin 'tpope/vim-fugitive.git'
  Plugin 'tpope/vim-rails.git'
  Plugin 'tpope/vim-surround.git'
  Plugin 'tpope/vim-dispatch'
  Plugin 'tpope/vim-rvm'
  Plugin 'tpope/vim-vinegar'
  Plugin 'tpope/vim-unimpaired'
  Plugin 'mattn/gist-vim'
  " required for gist-vim to work
  Plugin 'mattn/webapi-vim'
  Plugin 'wellle/targets.vim'

  Plugin 'vim-scripts/Align'
  Plugin 'vim-scripts/bufexplorer.zip'
  Plugin 'vim-scripts/vim-indent-object'
  " Plugin 'vim-scripts/LustyJuggler'
  " Plugin 'vim-ruby/vim-ruby'
  " Plugin 'rking/vim-ruby-refactoring'
  " Plugin 'skwp/vim-rspec'
  Plugin 'kien/ctrlp.vim'
  Plugin 'kchmck/vim-coffee-script'

  Plugin  'jceb/vim-orgmode'

  " AsyncCommand is required for vim-pomodoro
  Plugin 'pydave/AsyncCommand'
  Plugin 'metalelf0/vim-pomodoro'

  Plugin 'jtratner/vim-flavored-markdown'
  Plugin 'bling/vim-airline'
  " Plugin 'Lokaltog/vim-easymotion'
  Plugin 'rking/ag.vim'
  " Plugin 'bronson/vim-trailing-whitespace'
  Plugin 'justinmk/vim-sneak'
  Plugin 'freitass/todo.txt-vim.git'
  " Plugin 'Yggdroot/indentLine'

  " colorschemes
  Plugin 'Pychimp/vim-luna'
  Plugin 'Pychimp/vim-sol'
  Plugin 'Valloric/vim-valloric-colorscheme'
  Plugin 'chriskempson/base16-vim'
  Plugin 'chriskempson/vim-tomorrow-theme'
  Plugin 'dhruvasagar/vim-railscasts-theme'
  Plugin 'euclio/vim-nocturne'
  Plugin 'jaromero/vim-monokai-refined'
  Plugin 'johnallen3d/made-of-code.vim'
  Plugin 'julienXX/Hemisu'
  Plugin 'junegunn/seoul256.vim'
  Plugin 'metalelf0/Sift'
  Plugin 'metalelf0/Smyck-Color-Scheme.git'
  Plugin 'molok/vim-vombato-colorscheme'
  Plugin 'nanotech/jellybeans.vim'
  Plugin 'vim-scripts/blackboard.vim'
  Plugin 'vim-scripts/mayansmoke'
  Plugin 'vim-scripts/inkpot'
  Plugin 'vim-scripts/herald.vim'
  Plugin 'baverman/vim-babymate256'
  Plugin 'gregsexton/Muon'
  Plugin 'altercation/vim-colors-solarized'
  Plugin 'itchyny/landscape.vim'
  Plugin 'tomasr/molokai'
  Plugin 'Keithbsmiley/rspec.vim'
  Plugin 'abra/obsidian2'

call vundle#end()

filetype plugin indent on

  " Plugin 'Shougo/unite.vim'
  " Plugin 'Shougo/vimproc.vim'

" drastic remaps!
noremap H ^
noremap L $
inoremap kj <Esc>

nnoremap <C-j> :bprevious<CR>
nnoremap <C-k> :bnext<CR>

" macbook remaps!
nnoremap <D-Right> :tabnext<CR>
nnoremap <D-Left>  :tabprevious<CR>

" " xmpfilter
" map <Leader>xa <Plug>(xmpfilter-mark)
" map <Leader>xr <Plug>(xmpfilter-run)

" bufexplorer
" don't go to the active window
let g:bufExplorerFindActive=0

" " airline: use powerline fonts
let g:airline_powerline_fonts=1

" airline customization

function! AddPomoToAirline(ext)
  call a:ext.add_statusline_funcref(function('AddPomo'))
endfunction

function! AddPomo(...)
  let w:airline_section_c = get(w:, 'airline_section_c', g:airline_section_c)
  let w:airline_section_c .= g:airline_left_sep . ' %{PomodoroStatus()}'
endfunction

nnoremap <D-Up> :bn<CR>
nnoremap <D-Down> :bp<CR>
" nnoremap <silent> <Space> za
" vnoremap <silent> <Space> za<Esc>
map <Leader>fi :set foldmethod=indent<cr>
map <Leader>fm :set foldmethod=manual<cr>

" select last paste in visual mode
nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'


" Qargs loads quickfix filenames into args list
command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
 
" populate the argument list with each of the files named in the quickfix list
function! QuickfixFilenames()
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

nnoremap n nzz
nnoremap N Nzz

" Use Q to intelligently close a window 
" (if there are multiple windows into the same buffer)
" or kill the buffer entirely if it's the last window looking into that buffer
function! CloseWindowOrKillBuffer()
  let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))

  " We should never bdelete a nerd tree
  if matchstr(expand("%"), 'NERD') == 'NERD'
    wincmd c
    return
  endif

  if number_of_windows_to_this_buffer > 1
    wincmd c
  else
    bdelete
  endif
endfunction

nnoremap <silent> Q :call CloseWindowOrKillBuffer()<CR>

function! Agg(pattern)
  Ag pattern $(git ls-files)
endfunction

set foldlevelstart=20

autocmd BufNewFile,BufRead *.rb set foldmethod=indent

" Extra vimrc {{{
let s:extrarc = expand($HOME . '/.vim/passwords.vim')
if filereadable(s:extrarc)
    exec ':so ' . s:extrarc
endif
" }}}

" speedy terminal
" -----------------------------------
set ttyfast
set notimeout
set ttimeout
set ttimeoutlen=100
syntax sync minlines=256
set synmaxcol=500

colo herald
